## 微服务项目
```shell
# 单体架构(SpringBoot)：将所有业务功能集中在一个项目中打包部署
# 优点：架构简单、部署成本低、适合小型项目
# 缺点：
# 协作成本高：数十个人协作开发同一个项目,要把不同功能模块的代码合并到一个分支,很容易陷入解决冲突的泥潭
# 发布效率低：任何模块变更都需要发布整个系统,发布一次需要耗费很长时间
# 系统性能差：所有请求都堆在一个tomcat服务器,如果某个接口被大量访问会影响其它接口的响应速度(可通过.jmx测试)

# jmeter接口压测
# wget https://dlcdn.apache.org//jmeter/binaries/apache-jmeter-5.6.3.tgz
# bin/jmeter.sh 启动会弹出jmeter
# 测试计划 - 添加 - 线程(用户) - 线程组 - 单体项目接口压测(名字随便起) - 线程属性 - 线程数100/200/300、时间1秒、循环次数永远
# 单体项目接口压测 - 添加 - 取样器 - HTTP请求 - 协议、服务器IP、端口、路径
# 单体项目接口压测 - 添加 - 监听器 - 查看结果树、汇总报告
# 测试方法：通过给某个接口不断加并发线程数,然后查看其它接口的响应时间

# 微服务架构(SpringCloud)：按照功能拆分成用户、商品、购物车、订单、支付等独立模块,部署在不同tomcat服务器,每个小团队负责一个模块,适合大型项目
# 何时拆分：初创型公司先采用单体项目,快速试错,随着项目发展到一定规模再做拆分
# 拆分目标：低耦合高内聚,按照业务模块拆分,每个服务尽量独立,减少对其它服务的依赖
# 拆后问题：数据分布在不同服务,本地无法直接调用,可通过RestTemplate模拟前端发送Http请求实现RPC远程调用(Remote Producer Call)
```

## 商品微服务
```shell
# 包含首页、分类、商品列表、商品详情等接口
# 首页数据会频繁访问且很少修改,因此可以使用缓存提高页面加载速度,详见CategoryServiceImpl

# 整合Redis
# 场景启动器：spring-boot-starter-data-redis - io.lettuce.lettuce-core
# 自动配置类：org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration - @Bean注册组件RedisTemplate
# 绑定属性类：org.springframework.boot.autoconfigure.data.redis.RedisProperties
# 修改配置项：@ConfigurationProperties(prefix = "spring.data.redis") - application.yml

# RedisTemplate缺点：业务方法中要手写大量读写缓存的代码,要是有框架能自动实现就好了
# SpringCache是一个缓存框架,只需添加注解就能实现缓存功能,大大简化操作缓存的业务代码
# CacheManager接口的常用实现类包括RedisCacheManager、EhCacheCacheManager、GuavaCacheManager

# 整合SpringCache
# 场景启动器：starter-xxx - spring-boot-starter - spring-boot-autoconfigure
# 自动配置类：org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration - 提供了CacheManager接口
# 绑定属性类：org.springframework.boot.autoconfigure.cache.CacheProperties
# 修改配置项：@ConfigurationProperties(prefix = "spring.cache") - application.yml

# 使用步骤
# 1.注册CacheManager组件,设置redis的序列化器和过期时间
# 2.在启动类添加@EnableCaching开启缓存
# 3.在业务方法添加
# @Cacheable  针对查询操作：先查缓存,命中就直接返回,没命中就再查数据库并将结果更新到缓存
# @CachePut   针对更新操作：更新数据库时也往缓存中更新一份
# @CacheEvict 针对删除操作：删除数据库时也要删除对应的缓存
```