## 微服务项目
```shell
# 单体架构(SpringBoot)：将所有业务功能集中在一个项目中打包部署
# 优点：架构简单、部署成本低、适合小型项目
# 缺点：
# 协作成本高：数十个人协作开发同一个项目,要把不同功能模块的代码合并到一个分支,很容易陷入解决冲突的泥潭
# 发布效率低：任何模块变更都需要发布整个系统,发布一次需要耗费很长时间
# 系统性能差：所有请求都堆在一个tomcat服务器,如果某个接口被大量访问会影响其它接口的响应速度(可通过.jmx测试)

# jmeter接口压测
# wget https://dlcdn.apache.org//jmeter/binaries/apache-jmeter-5.6.3.tgz
# bin/jmeter.sh 启动会弹出jmeter
# 测试计划 - 添加 - 线程(用户) - 线程组 - 单体项目接口压测(名字随便起) - 线程属性 - 线程数100/200/300、时间1秒、循环次数永远
# 单体项目接口压测 - 添加 - 取样器 - HTTP请求 - 协议、服务器IP、端口、路径
# 单体项目接口压测 - 添加 - 监听器 - 查看结果树、汇总报告
# 测试方法：通过给某个接口不断加并发线程数,然后查看其它接口的响应时间

# 微服务架构(SpringCloud)：按照功能拆分成用户、商品、购物车、订单、支付等独立模块,部署在不同tomcat服务器,每个小团队负责一个模块,适合大型项目
# 何时拆分：初创型公司先采用单体项目,快速试错,随着项目发展到一定规模再做拆分
# 拆分目标：低耦合高内聚,按照业务模块拆分,每个服务尽量独立,减少对其它服务的依赖
# 拆后问题：数据分布在不同服务,本地无法直接调用,可通过RestTemplate模拟前端发送Http请求实现RPC远程调用(Remote Producer Call)
```

## 商品微服务
```shell
# 包含首页、分类、商品列表、商品详情等接口
# 首页数据会频繁访问且很少修改,因此可以使用缓存提高页面加载速度,详见CategoryServiceImpl

# 整合Redis
# 场景启动器：spring-boot-starter-data-redis - io.lettuce.lettuce-core
# 自动配置类：org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration - @Bean注册组件RedisTemplate
# 绑定属性类：org.springframework.boot.autoconfigure.data.redis.RedisProperties
# 修改配置项：@ConfigurationProperties(prefix = "spring.data.redis") - application.yml

# RedisTemplate缺点：业务方法中要手写大量读写缓存的代码,要是有框架能自动实现就好了
# SpringCache是一个缓存框架,只需添加注解就能实现缓存功能,大大简化操作缓存的业务代码
# CacheManager接口的常用实现类包括RedisCacheManager、EhCacheCacheManager、GuavaCacheManager

# 整合SpringCache
# 场景启动器：starter-xxx - spring-boot-starter - spring-boot-autoconfigure
# 自动配置类：org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration - 提供了CacheManager接口
# 绑定属性类：org.springframework.boot.autoconfigure.cache.CacheProperties
# 修改配置项：@ConfigurationProperties(prefix = "spring.cache") - application.yml

# 使用步骤
# 1.注册CacheManager组件,设置redis的序列化器和过期时间
# 2.在启动类添加@EnableCaching开启缓存
# 3.在业务方法添加
# @Cacheable  针对查询操作：先查缓存,命中就直接返回,没命中就再查数据库并将结果更新到缓存
# @CachePut   针对更新操作：更新数据库时也往缓存中更新一份
# @CacheEvict 针对删除操作：删除数据库时也要删除对应的缓存
```

## Nacos
```shell
# 远程调用问题：高并发场景商品微服务会多实例部署,那么购物车作为调用方,如何知道每个实例地址?到底该调用哪个实例?如何感知实例上下线?
# 远程调用包含服务提供者和服务消费者两个角色,大型微服务项目通常包含大量的服务提供者,为了管理这些服务引入注册中心的概念

# 服务治理中的三个角色：服务提供者、注册中心、服务消费者
# 消费者如何获取提供者的地址：提供者启动时会注册到注册中心,消费者从注册中心拉取和订阅服务
# 消费者如何选择多实例提供者：消费者通过随机、轮询、hash等负载均衡算法从多实例提供者中选一个
# 消费者如何感知服务状态变更：提供者通过心跳机制向注册中心报告自己的健康状态,心跳异常时注册中心会剔除异常服务并通知消费者

# Nacos(Dynamic Naming and Configuration Service)
# 官网地址：https://nacos.io/zh-cn/
# 本地安装：unzip nacos-server-2.2.2.zip
# 启动：bin/startup.sh -m standalone
# 关闭：bin/shutdown.sh
# 打开页面：http://localhost:8848/nacos  用户名和密码:nacos/nacos

# 整合Nacos
# 场景启动器：spring-cloud-starter-alibaba-nacos-discovery
# 自动配置类：com.alibaba.cloud.nacos.discovery.NacosDiscoveryAutoConfiguration
# 绑定属性类：com.alibaba.cloud.nacos.NacosDiscoveryProperties
# 修改配置项：@ConfigurationProperties("spring.cloud.nacos.discovery") - application.yml

# 服务注册与发现步骤
# 1.pom.xml引入nacos依赖,同时包含了服务的注册与发现,因为每个微服务既可以是提供者也可以是消费者
# 2.application.yml配置nacos地址
# 3.启动服务实例,可在nacos界面的服务列表中查看

# 微服务模块启动日志
# nacos registry, DEFAULT_GROUP service-gateway 172.18.68.69:8500 register finished
# nacos registry, DEFAULT_GROUP service-product 172.18.68.69:8511 register finished
# nacos registry, DEFAULT_GROUP service-product 172.18.68.69:8521 register finished
```